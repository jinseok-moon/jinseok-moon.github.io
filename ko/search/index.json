[{"content":"Until now 기존의 CUDA 프로그래밍은 CUDA C++을 바탕으로 하고 있었다. SIMT 기반으로 데이터를 블록과 스레드에 맵핑해줄 필요가 있다. 세밀한 설계를 통해 최선의 성능을 이끌어 낼 수 있으나, 모두가 손쉽게 할 수 있지는 않은 일이다. 또한 GPU 아키텍쳐가 발전함에 따라서 하드웨어 스펙도 달라지니 커널 개발자는 각 GPU에 맞는 최선의 커널을 다르게 개발해야했다.\n이런 어려움에 대해 떠오른 것이 triton-language다(NVIDIA Triton Inference Server와는 관계가 없다). Triton은 메모리관리, 동기화, 텐서코어 스케쥴링 등 블록 레벨의 추상화를 통해 접근성을 높였다. 이에 더해 MLIR을 통해 NVIDIA GPU뿐 아니라 AMD, NPU 등 다양한 하드웨어 백엔드로 이어질 수 있는 수단으로 확장된 추세이다.\n물론 NVIDIA에서도 이런 어려움을 극복하기 위한 CUTLASS와 같은 라이브러리를 제공한다. 작은 타일 레벨의 operation들을 템플릿화해서 최적의 커널을 비교적 손쉽게 개발할 수 있다. FlashAttention-3도 CUTLASS 기반으로 작성되었다. 하지만 비교적 쉬운게, 진짜 쉬운건 아니다. 수많은 템플릿과 로직을 알고 있어야했다. 이 또한 결국 CUDA C++을 알아야한다.\nCUDA Tile IR 그러던 와중 2025년 봄에 발표된 내용. NVIDIA에서 타일 기반의 프로그래밍 모델을 개발한다는 소식이다. 언제 공개되나 기다렸는데 25년이 다 가기전에 공개했다.\ncuTile은 기존 SIMT 기반 프로그래밍 모델과 같은 레벨에 머무른다. 이야기는 즉슨 CUDA C++ 코드 개발 -\u0026gt; PTX -\u0026gt; CUBIN 으로 이어지던 패스에 더해서 Tile IR -\u0026gt; CUBIN 으로 이어지는 패스가 추가된 것이다.\nTile IR은 MLIR Dialect 기반으로 구성될 예정이고, bytecode로 저장된다고 한다. 직접 Tile IR를 건드리는 부분을 개발할 것이 아니라면 cuTile Python을 사용하면 된다.\nNVIDIA cuTile Python: 대부분의 개발자는 여기에 해당된다. CUDA Tile IR을 백엔드로 사용하는 Python 구현체이다. CUDA Tile IR: 자체 DSL 컴파일러 또는 라이브러리를 개발하려는 개발자는 CUDA Tile IR을 사용한다. cuTile Python: how-to install 개발 환경은 공식문서에서 가지고 왔다.\nLinux x86_64, Linux aarch64 or Windows x86_64 A GPU with compute capability 10.x or 12.x NVIDIA Driver r580 or later CUDA Toolkit 13.1 or later Python version 3.10, 3.11, 3.12 or 3.13 환경이 구성되었다면, pip으로 설치하자. torch 또한 환경에 맞춰서 설치하면 된다.\npip install cuda-tile pip install cupy-cuda13x # For sample pip install pytest numpy # For test Key concepts: Tile vs. SIMT 타일 모델(왼쪽)은 데이터를 블록으로 분할하고 컴파일러는 이를 스레드에 매핑한다. SIMT 모델(오른쪽)은 데이터를 블록과 스레드 모두에 매핑한다. SIMT는 각 스레드를 모두 컨트롤할 수 있지만, 그만큼 최상의 성능을 위해서는 하드웨어의 복잡성을 고려한 수동 튜닝이 필요하다. 타일모델은 하드웨어의 복잡성을 일부 추상화함으로써 CUDA 컴파일러/런타임이 타일 알고리즘을 내부적으로 처리하게 하고, 유저는 알고리즘 개발에 집중할 수 있게 한다.\nKernel Definition @ct.kernel 데코레이터는 Python 함수를 GPU 커널로 컴파일한다. 위에서 알아본것처럼, 이 커널의 내용은 CUDA C++ 을 거쳐서 ptx가 만들어지는 것이 아니라 Tile IR로 내려오고 MLIR을 통해서 CUDA TILE IR을 사용하여 cubin을 생성한다.\nimport cuda.tile as ct @ct.kernel def vector_add(a, b, c, tile_size: ct.Constant[int]): ... class kernel(TileDispatcher): constant_flags = get_constant_arg_flags(function) compiler_options = CompilerOptions( num_ctas=num_ctas, occupancy=occupancy, opt_level=opt_level ) compile = _compile.CompileCallback(function, compiler_options) super().__init__(constant_flags, compile) self._pyfunc = function Tutorial w/ vector addition CUDA 프로그래밍의 가장 기초인 vector addition kernel을 통해 어떻게 사용하는지 알아보자.\n__global__ void vecAdd(float* A, float* B, float* C, int vectorLength) { /* calculate my thread index */ int workIndex = threadIdx.x + blockIdx.x*blockDim.x; if(workIndex \u0026lt; vectorLength) { /* perform the vector addition */ C[workIndex] = A[workIndex] + B[workIndex]; } } 1D Tile 가장 단순한 형태의 cuTile 커널이다.\nGPU 메모리에서 하나 이상의 타일 로드 타일에 대한 계산을 수행하여 새로운 타일을 생성 결과 타일을 GPU 메모리에 저장 import cuda.tile as ct @ct.kernel def vector_add(a, b, c, tile_size: ct.Constant[int]): # Get the 1D pid, blockIdx.x in cuda c++ pid = ct.bid(0) # Load input tiles a_tile = ct.load(a, index=(pid,) , shape=(tile_size, ) ) b_tile = ct.load(b, index=(pid,) , shape=(tile_size, ) ) # Perform elementwise addition result = a_tile + b_tile # Store result ct.store(c, index=(pid, ), tile=result) ct.bid(0)는 axis-0을 따라 블록ID를 가져온다. CUDA C++에서 blockIdx 를 가져오는 것과 동일하다. ct.load()는 필요한 인덱스, 타일모양만큼 메모리에서 데이터를 로드한다. 불러온 a_tile, b_tile을 더하는 것은 + 연산자로 충분하며, 그 결과는 result 타일에 가지고 있고, 이 타일은 아직 DRAM에는 저장되지 않았으니, ct.store()를 통해 저장한다.\n2D Tile 1D 타일을 2D로 reshape하면 행렬 연산에 적합한 형태가 된다. 인덱싱은 다음과 같이 정말 직관적이다.\n@ct.kernel def vec_add_kernel_2d(a, b, c, TILE_X: ct.Constant[int], TILE_Y: ct.Constant[int]): # Get the global IDs of the current block along the X and Y axes. # `ct.bid(0)` for the first grid dimension (typically rows), # `ct.bid(1)` for the second grid dimension (typically columns). bid_x = ct.bid(0) bid_y = ct.bid(1) # Load `TILE_X` x `TILE_Y` chunks from input matrices \u0026#39;a\u0026#39; and \u0026#39;b\u0026#39;. # The `index=(bid_x, bid_y)` specifies the 2D tile to load. a_tile = ct.load(a, index=(bid_x, bid_y), shape=(TILE_X, TILE_Y)) b_tile = ct.load(b, index=(bid_x, bid_y), shape=(TILE_X, TILE_Y)) # Perform the element-wise addition on the loaded tiles. sum_tile = a_tile + b_tile # Store the resulting `TILE_X` x `TILE_Y` chunk back to the output matrix \u0026#39;c\u0026#39;. ct.store(c, index=(bid_x, bid_y), tile=sum_tile) When tiles don\u0026rsquo;t fit 위의 두 예시는 전체 데이터 사이즈가 타일사이즈에 딱 나누어 떨어지는 경우다. 타일에 align되지 않는 경우에는 ct.gather(), ct.scatter() 를 사용한다. 2의 제곱이 아닌 경우에도 추천된다. 범위를 벗어나는 경우, padding_value (default:0) 가 반환된다.\n@ct.kernel def vec_add_kernel_2d_gather( a, b, c, TILE_X: ConstInt, TILE_Y: ConstInt # Tile dimensions for this block ): # Get the global IDs of the current block along the X and Y axes. bid_x = ct.bid(0) bid_y = ct.bid(1) # Calculate X and Y indices within the current block\u0026#39;s tile. x = bid_x * TILE_X + ct.arange(TILE_X, dtype=torch.int32) y = bid_y * TILE_Y + ct.arange(TILE_Y, dtype=torch.int32) # Reshape the X and Y indices to (TILE_X, 1) and (1, TILE_Y), respectively. # This way, they can be broadcasted together to a common shape (TILE_X, TILE_Y). x = x[:, None] y = y[None, :] # Load elements using the calculated X and Y indices. # Both `a_tile` and `b_tile` have shape (TILE_X, TILE_Y). a_tile = ct.gather(a, (x, y)) b_tile = ct.gather(b, (x, y)) # Perform the element-wise addition. sum_tile = a_tile + b_tile # Store the result back to `c` using the same index tiles. # `ct.scatter()` only writes data to positions within the array bounds. ct.scatter(c, (x, y), sum_tile) Performance cutile-python/test/bench_matmul.py 을 돌려보면 결과는 다음과 같다. Torch kernel은 내부적으로 cutlass 커널을 호출한다. 아직 torch에 비해서 성능이 느리지만, tile-based programming이 가능해짐으로써 커널 구현 난이도가 크게 감소한 것은 희망차다. IR 또한 오픈소스로 공개되었으니 성능적인 면에서는 앞으로 점차 개선될 것이다.\n--------------------------------------------------------------------------------------------------- benchmark \u0026#39;matmul\u0026#39;: 12 tests --------------------------------------------------------------------------------------------------- Name (time in us) Min Max Mean StdDev Median IQR Outliers OPS Rounds Iterations ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ bench_matmul[1K-1K-1K-f16-torch] 14.3439 (1.0) 14.3451 (1.0) 14.3443 (1.0) 0.0005 (1.0) 14.3441 (1.0) 0.0005 (1.0) 1;0 69,714.0067 (1.0) 5 5244 bench_matmul[1K-1K-1K-f32-torch] 26.6370 (1.86) 26.6386 (1.86) 26.6374 (1.86) 0.0006 (1.37) 26.6372 (1.86) 0.0005 (1.02) 1;1 37,541.1889 (0.54) 5 3218 bench_matmul[1K-1K-1K-f16-cutile] 154.3699 (10.76) 154.4450 (10.77) 154.4040 (10.76) 0.0277 (58.67) 154.4062 (10.76) 0.0332 (73.27) 2;0 6,476.5145 (0.09) 5 613 bench_matmul[1K-1K-1K-f32-cutile] 892.8400 (62.25) 893.2511 (62.27) 893.0082 (62.26) 0.1616 (342.04) 893.0112 (62.26) 0.2286 (505.17) 2;0 1,119.8106 (0.02) 5 112 References https://docs.nvidia.com/cuda/cutile-python/ https://developer.nvidia.com/blog/focus-on-your-algorithm-nvidia-cuda-tile-handles-the-hardware https://developer.nvidia.com/blog/simplify-gpu-programming-with-nvidia-cuda-tile-in-python ","date":"2026-01-12T00:00:00Z","permalink":"https://jinseok-moon.github.io/ko/p/cuda-tile/","title":"CUDA Tile IR, cuTile Python"},{"content":"GPU는 계속 세대가 발전했고, 그에 따라서 feature들이 바뀌었다. LLM을 다룰것이라면 Ampere 부터의 GPU의 하드웨어적 특성을 알면 좋다. A100, H100 등 각 아키텍쳐의 대표적인 GPU를 통해 알아보자. 텐서코어의 TOPS 같은 성능수치는 다루지 않는다.\nA100: Ampere (SM80, 2020) 2020년 발표된 GPU로, L1 bypass를 통해서 많은 과정이 생략되면서 DRAM의 값을 Shared Memory (SRAM)에 불러오는 것이 최적화되었다.\ncp.async ptx로 구성되는 이 메모리 복사는 비동기적으로 일어나기 때문에 다음과 같은 소프트웨어 파이프라인을 통해서 latency를 숨길 수 있다.\n소프트웨어 파이프라인은 연속된 명령어의 종속성을 제거해서 하드웨어를 fully utilize 하는 기법이다. 메모리 instruction LSU(Load Store Unit)에서 처리되고, 행렬곱은 연산장치(Tensor Core)에서 처리되므로, 하드웨어 종속성은 문제가 되지 않는다. 하지만 다음과 같은 데이터 종속성은 문제가 될 수 있다.\nfor (i=0; i\u0026lt;N-1; i++) { load_to_register(i); compute(i); } load_to_register(i) 가 완료될 때까지 compute(i) 를 실행할 수 없다. load된 i의 데이터가 필요하기 때문이다. 따라서 파이프라인을 구성한다.\nload_to_register(0); for (i=0; i\u0026lt;N-2; i++) { load_to_register(i+1); compute(i); } compute(N-1); 이렇게 하면 두 instruction 사이에 종속성이 제거되어 동시에 실행할 수 있다. 이 로직을 최대한 활용한 커널이 바로 Flash-Attention-2다. 저자의 말에 따르면 Ampere에서의 이론적 최대 성능에 근접한 값이라고 한다. 다른 포스트에서 설명하겠지만 mixed-precision gemm kernel Marlin 또한 최적화된 커널의 하나다.\nH100: Hopper (SM90, 2022) 2022년 GTC에서 발표된 Hopper 아키텍쳐이다. Ampere보다 훨씬 좋은 성능이다. 성능의 개선은 크게 TMA, WGMMA, Warp-Specialization 세가지를 다룬다. 미리 언급하면, H100의 feature를 활용한 커널에는 Flash-Attention-3, Machete 등이 있다.\nTensor Memory Accelerator (TMA) Ampere에서 L1 bypass를 통한 memory instruction의 성능 개선을 이루었다. 하지만 이를 위해서는 직접 메모리 주소와 stride 계산을 해주고 동기화에 관한 barrier까지 모두 관리해주어야했다. 그래서 NVIDIA는 여기에 만족하지 않고 TMA라는 유닛을 개발했다. TMA를 이용하면 텐서의 정보를 이용해서 대량의 데이터를 복사한다. 또한, 이 TMA instruction은 단일 스레드에서 launch되기 때문에 자원을 더욱 효율적으로 사용가능하다.\nWarp Group Matrix Multiply-Accumulate (WGMMA) Ampere까지의 mma는 모두 단일 warp 기반 instruction이다. NVIDIA가 극한의 효율을 추구한 결과, 4개의 warp를 묶어서 mma를 처리하도록 만들었다.\nWarp Specialization: Consumer-Producer 이건 Hopper의 기능을 활용한 테크닉이다.Hopper는 각 warp가 사용할 register 개수를 지정해 줄 수 있게 되었다. 이 정보를 염두하고서 파이프라인을 살펴보면 1) memory 2) computation 의 두가지 큰 줄기가 있다. 당연히 memory instruction에서는 레지스터가 상대적으로 적게 필요할것이다. 분업에 따른 레지스터 차등분배는 다음과 같다.\nProduer warp group. TMA를 활용한 메모리 instruction 담당. 레지스터를 적게 가져도 충분함. 열심히 메모리를 불러옴. Consumer warp group. 텐서코어를 활용한 WGMMA isntruction 담당. 레지스터를 많이 가져가서 열심히 연산함. Blackwell (SM100, 2024) 2024 GTC에서 발표된 차세대 GPU. 이번에도 많은 것이 바뀌었다. 우선, WGMMA는 더이상 사용되지 않는다. Hopper 단일 아키텍쳐 지원 instruction이라니! 대신 UMMA가 생겼다. UMMA는 다음과 같은 입력 조건이 있다.\nOperand A: TMEM or SMEM Operand B: SMEM Accumulator: TMEM Tensor Memory (TMEM), TMEM이 무엇일까? Blackwell에서 새로 생긴 구조로, accumulator가 이곳에 있다는 것은 UMMA에서 데이터 처리를 위해 register가 필요하지 않음을 의미한다. 뭐라고? 단일 스레드 실행에, 레지스터까지 필요없다고? TMA까지 활용하면 CTA(Cooperative Thread Array, 쉽게 말하면 CUDA kernel에서의 블록을 의미)에서 할 일은 전/후처리만 남는다.\n과거의 역사적 맥락에서 이러한 발전들은 범용 리소스를 다른 작업에 사용할 수 있도록, 연산들을 특수 하드웨어 리소스로 대체, 분리하는 추세임을 알 수 있겠다.\nVolta: Tensor Core로 행렬 연산을 일반 연산 파이프라인에서 분리 Ampere: async copy로 데이터 로딩과 계산을 동시에 수행, 진정한 파이프라인화 Hopper: TMA와 WGMMA로 데이터 이동과 MMA를 비동기, 저비용으로 겹쳐 실행 Blackwell: TMEM과 UMMA로 MMA 자체를 단일 스레드, 비동기로 처리해 레지스터 부담 제거 Grace-Blackwell GB200 NVIDIA의 Grace CPU와 Blackwell GPU를 엮은 아키텍쳐. 위에서 이야기 한 것은 모두 GPU내부에서 일어나는 일들이다. 우리는 host(CPU)로부터 device(GPU)로 메모리를 복사해줄 필요가 있다. 어떻게? 기존에는 PCIe로.. 아 이게 많이 느리다. 그래서 NVLink로 둘을 붙였고, 그래서 Grace Blackwell이다. 당연히 PCIe보다 훨씬 빠를 것.\nBlackwell Geforce RTX 50 series (SM120, 2025) Blackwell 기반의 Geforce GPU다. 참 비싼 가격이 요즘은 조금 내려온 것 같기도..? Blackwell 아키텍쳐지만 위에서 열심히 이야기한 TMEM이 없다. TMA는 있다. 그래서 LLM에 활용하려면 Ampere식 파이프라인에 TMA를 쓰는 정도일 듯 싶지만, 이걸 굳이 할 이유는 별로 없다. 물론 텐서코어 성능은 비교할 수 없이 좋아졌다.\nReferences CUTLASS Tutorial: Efficient GEMM kernel designs with Pipelining CUTLASS Tutorial: Writing GEMM Kernels Using Tensor Memory For NVIDIA® Blackwell GPUs ","date":"2025-11-24T00:00:00Z","permalink":"https://jinseok-moon.github.io/ko/p/archs/","title":"GPU Architecture w/ LLM"},{"content":"Arithmetic Intensity (AI) Arithmetic intensity, 산술강도는 연산량/메모리량, ops/byte(mem) 으로 나타낸다. 즉 AI가 높을수록 동일한 메모리로 더 많은 연산을 할 수 있음을 의미한다. 이전 챕터에서는 SRAM (Shared memory of CUDA), 1d tiling 을 활용해서 성능을 끌어올렸다. 한개의 스레드에서 아래와 같이 여러개의 결과를 만들어낸다. 살펴본 경우와 더불어 확장된 알고리즘의 AI를 생각해보자.\n앞서 살펴본 커널에서, 한개의 결과만 만들어내는 경우는 17 load 가 필요하다. 반면 1d tiling을 하는것만으로도 11 load 로 줄어들게 되는데, 2d tiling을 하게 되면 9 load로 그보다 더 줄어든다. 이는 GEMM 연산의 특징으로 메모리를 재사용하는 방향으로 최적화를 더 진행해야됨을 알 수 있다.\n4. SRAM 2d tilling 2d tiling이 더욱 효과적인 것을 알았으니 이제 구현해보자. TN 변수를 추가해서 loop를 확장한다.\nint totalResultsBlocktile = BM * BN; // 128*128=16384 int numThreadsBlocktile = totalResultsBlocktile / (TM * TN); // 16384/(8*8)=256 int strideA = numThreadsBlocktile / BK; // 256/8=32 for (int bkIdx = 0; bkIdx \u0026lt; K; bkIdx += BK) { for (int offset = 0; offset \u0026lt; BM; offset += strideA) { A_shared[(innerRowA + offset) * BK + innerColA] = A[(innerRowA + offset) * K + innerColA]; } for (int offset = 0; offset \u0026lt; BK; offset += strideB) { B_shared[(innerRowB + offset) * BN + innerColB] = B[(innerRowB + offset) * N + innerColB]; } __syncthreads(); A += BK; B += BK * N; for (int dotIdx = 0; dotIdx \u0026lt; BK; dotIdx++) { for (int i = 0; i \u0026lt; TM; i++) { regM[i] = A_shared[(threadRow * TM + i) * BK + dotIdx]; } for (int i = 0; i \u0026lt; TN; i++) { regN[i] = B_shared[dotIdx * BN + threadCol * TN + i]; } for (int resIdxM = 0; resIdxM \u0026lt; TM; resIdxM++) { for (int resIdxN = 0; resIdxN \u0026lt; TN; resIdxN++) { threadResults[resIdxM * TN + resIdxN] += regM[resIdxM] * regN[resIdxN]; } } } __syncthreads(); } BM=BN=128, BK=TM=TN=8로 아래와 같이 커널을 실행시킨다. 한 블록당 스레드는 256개이다.\ntemplate \u0026lt;int BM, int BN, int BK, int TM, int TN\u0026gt; void launch_gpu_kernel_4(float *A, float *B, float *C, int M, int N, int K) { dim3 block((BM * BN) / (TM * TN)); dim3 grid(ceil_div(N, BN), ceil_div(M, BM)); gemm_gpu_4_sram_2d_tiling\u0026lt;BM, BN, BK, TM, TN\u0026gt; \u0026lt;\u0026lt;\u0026lt;grid, block\u0026gt;\u0026gt;\u0026gt;(A, B, C, M, N, K); } dotIdx를 loop unrolling 하면 위와 같이 생겼다. 우리는 총 16 SRAM load 만 하면 된다.\nDRAM: K/8 iters * 2 (=A+B) * 4 (=sizeSRAM/numThreads) loads SRAM: K/8 iters * 8 (=dotIdx) * 2 (=A+B) * 8 (=TM,=TN) loads Memory accesses per result: K/64 DRAM, K/4 SRAM 5. Vectorized SRAM 2d tiling GPU에서, SRAM을 load 하는 명령어 LDS는 128비트까지 지원 가능하다. 이 이야기는 즉, 위의 2d-tiling 커널에서 A를 전치시키면 한번에 보다 많은 데이터를 효율적으로 읽어올 수 있다는 뜻이다. LDS.128 명령어를 활용하기 위해서 A를 전치시키자. 그럼 우리가 이미 B를 불러올 때 하던 것처럼 모양이 나온다.\nfloat4 벡터 자료형을 이용하면, 128비트 명령어로 대체되고, 성능이 빨라진다.\nfloat4 tmp = reinterpret_cast\u0026lt;float4 *\u0026gt;(\u0026amp;A[innerRowA * K + innerColA * 4])[0]; // transpose A during the GMEM to SMEM transfer As[(innerColA * 4 + 0) * BM + innerRowA] = tmp.x; As[(innerColA * 4 + 1) * BM + innerRowA] = tmp.y; As[(innerColA * 4 + 2) * BM + innerRowA] = tmp.z; As[(innerColA * 4 + 3) * BM + innerRowA] = tmp.w; reinterpret_cast\u0026lt;float4 *\u0026gt;(\u0026amp;Bs[innerRowB * BN + innerColB * 4])[0] = reinterpret_cast\u0026lt;float4 *\u0026gt;(\u0026amp;B[innerRowB * N + innerColB * 4])[0]; __syncthreads(); ","date":"2025-11-08T00:00:00Z","permalink":"https://jinseok-moon.github.io/ko/p/gemm-2/","title":"GEMM 2"},{"content":"이 글은 포스트를 참고하며 직접 커널과 그림을 작성하며 진행한 공부이다.\nCUDA는 cuBLAS에서 최적화된 GEMM api를 제공한다. 직접 작성한 커널도 최적화를 통해서 충분히 cuBLAS 급의 성능을 낼 수 있다. 단계적으로 CUDA의 최적화 개념들을 적용하면서 따라가보자.\nA: (M, K), row-major B: (K, N), row-major C: (M, N), row-major DRAM: Global memory SRAM: Shared memory 구현은 다음과 같고, 결과를 먼저 보이면 아래와 같다.\nNaive implementation, DRAM coalescing SRAM caching SRAM 1d tiling [BENCHMARK] CUBLAS GEMM │ 0.045334 ms (w:10 r:20) [BENCHMARK] GPU GEMM 0 NAIVE │ 3.943722 ms (w:10 r:20) [PASSED] [BENCHMARK] GPU GEMM 0 DRAM COALESCING │ 0.517949 ms (w:10 r:20) [PASSED] [BENCHMARK] GPU GEMM 1 SRAM CACHING │ 0.248670 ms (w:10 r:20) [PASSED] [BENCHMARK] GPU GEMM 2 SRAM 1D TILING │ 0.249046 ms (w:10 r:20) [PASSED] 0. Naive implementation 가장 기본형태의 연산은 다음과 같이 한개의 스레드가 C의 한 element를 계산하기 위한 연산을 진행하는 것이다. Row-major이기 때문에 B를 load할 때 불연속적인 메모리를 읽어오는 단점이 있다. 이 동작을 warp-level에서의 GEMM operation을 나타내면 아래 그림과 같다.\nLoop 구조상 A를 load할 때 스레드들은 비연속적인 column 메모리에 접근하기에 memory coalescing이 불가능하다. Memory coalescing이 불가능하면 결국 warp 내에서 load operation이 32번 발생하게 되고, 이는 성능 크나큰 성능 저하를 가져온다.\nB를 load할 때는 모든 스레드가 같은 값에 접근하기 때문에 warp 내의 broadcast가 동작한다. 하지만 결과적으로 보면 이 스레드들을 하나의 워프로 묶는건 이점이 없다.\nDRAM coalescing 위와 같이 연속적인 메모리를 접근하여서 워프의 이점을 살려야한다. A를 load할때는 memory load - broadcast를 통해서 필요한 모든 데이터가 채워진다. B의 값을 load할때 warp내에서는 인접한 연속적인 메모리를 한번에 불러오므로 memory coalescing이 가능하다.\n__global__ void gemm_gpu_0_naive(int M, int N, int K, float alpha, float *A, float *B, float beta, float *C) { int tid = blockIdx.x * blockDim.x + threadIdx.x; int row = tid % N; int col = tid / N; ... } __global__ void gemm_gpu_0_dram_coalescing(int M, int N, int K, float alpha, float *A, float *B, float beta, float *C) { int tid = blockIdx.x * blockDim.x + threadIdx.x; int row = tid / N; int col = tid % N; ... } 두 커널의 코드 차이는 row, col의 계산방식 뿐이지만 실제 성능은 큰 차이가 난다. 프로파일링의 결과를 보면 성능 차이가 DRAM operation에서 발생하는 것을 확인할 수 있다.\n# RTX 5090 $ sudo /usr/local/cuda/bin/ncu --metrics dram__bytes.sum.per_second gemm gemm_gpu_0_naive(int, int, int, float, float *, float *, float, float *) (4096, 1, 1)x(256, 1, 1), Context 1, Stream 7, Device 0, CC 12.0 Section: Command line profiler metrics -------------------------- ----------- ------------ Metric Name Metric Unit Metric Value -------------------------- ----------- ------------ dram__bytes.sum.per_second Gbyte/s 2.40 -------------------------- ----------- ------------ gemm_gpu_0_dram_coalescing(int, int, int, float, float *, float *, float, float *) (4096, 1, 1)x(256, 1, 1), Context 1, Stream 7, Device 0, CC 12.0 Section: Command line profiler metrics -------------------------- ----------- ------------ Metric Name Metric Unit Metric Value -------------------------- ----------- ------------ dram__bytes.sum.per_second Gbyte/s 18.07 -------------------------- ----------- ------------ 1. SRAM caching Naive 구현체는 데이터를 반복해서 가져와야하는데, DRAM에서 여러번 가져오는 것은 성능적 손실이 크다. Paper에 따르면 V100 기준으로 DRAM bandwidth는 900 GB/s, SRAM bandwidth는 13,800 GB/s 이다 (SRAM bandwidth는 공식적으로 수치가 알려져있지는 않다). SRAM을 활용, 메모리를 최대한 재사용해서 성능을 올려보자.\n각 블록은 32x32 크기를 가지고 C의 결과값을 하나씩 담당해서 연산을 한다. 각 블록에서 필요로 하는 DRAM의 메모리는 위 그림의 빗금친 영역이다. bkIdx loop를 통해서 SRAM에 store할 영역으로 이동하고, tIter loop를 통해서 SRAM load - gemm 연산을 수행한다. 1 result per thread 이므로 결과값은 단일 변수 sum 에 누적해서 최종적으로 DRAM C에 저장한다.\ntemplate \u0026lt;int BLOCKSIZE\u0026gt; __global__ void gemm_gpu_1_sram_caching(int M, int N, int K, float alpha, float *A, float *B, float beta, float *C) { int bkRow = blockIdx.y; int bkCol = blockIdx.x; A += K * BLOCKSIZE * bkRow; B += BLOCKSIZE * bkCol; C += N * BLOCKSIZE * bkRow + BLOCKSIZE * bkCol; __shared__ float sA[BLOCKSIZE * BLOCKSIZE]; __shared__ float sB[BLOCKSIZE * BLOCKSIZE]; int tRow = threadIdx.x / BLOCKSIZE; int tCol = threadIdx.x % BLOCKSIZE; float sum = 0.0f; for (int bkIdx = 0; bkIdx \u0026lt; K; bkIdx += BLOCKSIZE) { sA[threadIdx.x] = A[tRow * K + tCol]; sB[threadIdx.x] = B[tRow * N + tCol]; __syncthreads(); A += BLOCKSIZE; B += BLOCKSIZE * N; for (int tIter = 0; tIter \u0026lt; BLOCKSIZE; tIter++) { sum += sA[tRow * BLOCKSIZE + tIter] * sB[tIter * BLOCKSIZE + tCol]; } __syncthreads(); } C[tRow * N + tCol] = alpha * sum + beta * C[tRow * N + tCol]; } 2. SRAM 1D tiling SRAM caching을 활용함으로써 성능이 향상되었지만 여전히 cuBLAS의 커널에 비해서는 부족하다. 단순하게 1개의 스레드가 1개의 결과를 만들어내는 SRAM caching 커널의 메모리 접근 패턴을 보면 다음과 같다. 즉, C 행렬 원소 한 개의 결과값을 만들기 위해서는 K/16 DRAM, K*2 SRAM 만큼의 메모리 접근이 필요한 것이다.\nDRAM: K/32 iterations of outer loop * 2 loads SRAM: K/32 iterations of outer loop * BLOCKSIZE (=32) * 2 loads Memory accesses per result: K / 16 DRAM, K * 2 SRAM 프로파일링 결과를 보면 MIO (Memory Input/Output) 에서 warp stall이 발생하고, 이로 인해 성능이 저하됨을 알 수 있다.\n이 문제는 동일한 메모리를 재활용하는 것으로 해결이 가능하다. 1개의 스레드가 8개의 element의 output을 만들어내게끔 타일링을 하면 다음과 같다.\nWarp 내에서 하나의 스레드는 column 방향으로 C matrix의 8개의 원소를 계산하게 구현하고, 이를 바탕으로 아까의 메모리 식을 다시 계산해보면,\nDRAM: K/8 iters (dotIdx) loop * 2 loads SRAM: K/8 iters (dotIdx) loop * BK(=8) * (1 + TM(=8)) Memory accesses per result: K/32 DRAM, K * 9/8 SRAM K/16 -\u0026gt; K/32 DRAM, K*2 -\u0026gt; K*9/8 SRAM 으로, 결과 한개당 메모리접근이 줄어들게 된다.\nfor (int bkIdx = 0; bkIdx \u0026lt; K; bkIdx += BK) { sA[innerRowA * BK + innerColA] = A[innerRowA * K + innerColA]; sB[innerRowB * BN + innerColB] = B[innerRowB * N + innerRowB]; __syncthreads(); A += BK; B += BK * N; for (int dotIdx = 0; dotIdx \u0026lt; BK; dotIdx++) { float _b = sB[dotIdx * BN + tCol]; for (int resIdx = 0; resIdx \u0026lt; TM; resIdx++) { sum[resIdx] += sA[(tRow * TM + resIdx) * BK + dotIdx] * _b; } } __syncthreads(); } 이 커널에서는 BM와 TM의 사이즈가 동일해야 한다. 한 블록의 스레드 개수는 (BM*BN/TM)개인데, 이 스레드 개수와 sA, sB의 사이즈가 동일해야 DRAM-\u0026gt;SRAM 을 손쉽게 수행할 수 있기 때문이다.\nsA[innerRowA * BK + innerColA] = A[innerRowA * K + innerColA]; sB[innerRowB * BN + innerColB] = B[innerRowB * N + innerRowB]; References How to Optimize a CUDA Matmul Kernel for cuBLAS-like Performance: a Worklog ","date":"2025-10-26T00:00:00Z","permalink":"https://jinseok-moon.github.io/ko/p/gemm-1/","title":"GEMM 1"},{"content":"Proper Thread Indexing and Memory Coalescing CUDA는 아래 그림과 같은 Grid - Block - Thread 의 논리적 계층구조를 사용한다. 블록 내부의 thread 는 3차원으로 구성할 수 있는데, 결론을 먼저 말하면 별다른 메모리 구조를 가지지 않는 한, 스레드 인덱스 (x, y, z) 는 (x + y Dx + z Dx Dy) 로 계산하라 이다. 왜 그런지 알아보자.\n이때, xyz dimension 순서를 마음대로 바꿔도 성능에 영향이 없을까? 답은 NO 다. CUDA Programming guide 에 나와있는 내용으로, 블록을 3차원으로 했을때의 id는 다음과 같이 계산된다.\n이걸 무시했을 때 실제 커널에서 어떤 영향을 끼치는지 알아보자. 다음과 같은 커널 두개가 있다고 생각해보자. 1024개 원소의 vector 2개를 더하고 output에 저장하는, 2 memory load and 1 save 연산이다.\nkernel_0: index를 x-y 순으로 계산 kernel_1: index를 y-x 순으로 계산 __global__ void kernel_0(int* d_vec_a, int* d_vec_b, int* output, int size) { int index = threadIdx.x * blockDim.y + threadIdx.y; output[index] = d_vec_a[index] + d_vec_b[index]; } __global__ void kernel_0(int* d_vec_a, int* d_vec_b, int* output, int size) { int index = threadIdx.y * blockDim.x + threadIdx.x; output[index] = d_vec_a[index] + d_vec_b[index]; } 논리 스레드를 각각 알맞는 메모리 주소에 매핑해줬기 때문에 두 커널의 연산 결과는 동일하다. 하지만 결과는 다르다. kernel_0 이 더 오래 걸린다.\nkernel_0 mean time: 0.0052768 ms kernel_1 mean time: 0.0028352 ms 이렇게 되는 이유는 CUDA thread가 warp-level로 instruction이 발생하기 때문이다. 한 개의 워프에서 memory load request가 발생하면, DRAM에서 연속된 128바이트를 온다. 하지만 필요한 데이터는 한개뿐이 없다. 쉽게 말하면 row-major matrix에서 col-major address 접근을 하고 있는것과 비슷하다는 말이다. 당연히 uncoalesced memory access로 인해 성능이 저하된다.\n","date":"2025-07-25T00:00:00Z","permalink":"https://jinseok-moon.github.io/ko/p/thread-indexing/","title":"Proper thread indexing and memory coalescing"},{"content":"Original softmax $$ \\sigma_i(\\mathbf{z}) = \\frac{e^{z_i}}{\\sum^K_{j=1}e^{z_j}} $$\nSoftmax의 수식은 위와 같다. 입력 벡터에 대해서 load 2번, store 1번, 총 3번의 메모리 접근이 필요하다. 이 함수의 의미는 주어진 값들 속에서 각각의 원소의 확률을 계산해준다. 유용한 함수이지만, 실제 컴퓨터상에서 구현하게 될 때는 부동소수점으로 인한 문제가 발생하기 쉽다. 부동소수점은 소수를 컴퓨터로 표현하는 방법인데, 중요한 점은 표현할 수 있는 범위가 한정된다는 것이다. 그런데 softmax 연산에는 지수함수($e^z$)의 특성으로 인해서 값이 아주 커진다. 이 값들의 합연산을 하면 overflow가 발생하기 쉽다. 또한 반대로 음수방향으로 생각하면 아주 작은 값으로 인해 $e^z$ 가 0에 가까워져버린다. 분모에 0이 들어가서 연산을 할 수 없는 오류가 발생해버리는 것.\nSafe softmax 이 문제를 해결하기 위해서 수식을 약간 바꾸어 max값을 빼주게 되면 벡터는 0 이하의 값을 갖게 되어 범위가 좁아지게 된다. 또한 분모에는 최대값을 뺀 결과중 하나는 자기자신이기 때문에 $e^0=1$ 을 보장하게되어, 분모가 0이 되는 경우도 방지한다.\n$$ \\sigma_i(\\mathbf{z}) = \\frac{e^{z_i - \\max(z)}}{\\sum^K_{j=1}e^{z_j-\\max(z)}} $$\n실제 하드웨어적 한계를 극복하면서도 수학적으로 동일한 결과이기 때문에 대부분은 safe softmax를 사용한다. 하지만 최대값 $m_k$ 를 구하는 과정이 추가되었기 때문에 메모리 접근이 4번으로 늘어나는 단점이 있다.\nOnline softmax calculation 메모리접근을 해결하는 방법이 online softmax 이다. Safe softmax 알고리즘을 살펴보면, 꼭 벡터의 max값이 필요한 것은 아니고 오버플로우를 방지할 정도의 큰 값이면 되는 것을 알 수 있다. 이 값은 Local max값으로부터 값을 갱신하면 된다.\n위 알고리즘의 분모 $d_V$ 를 구하는 방법은 점화식으로 나타낼 수 있다. 여기서 $e^m$ 항들은 지수법칙으로 빼낼 수 있음을 생각하자.\n이 수식 전개를 통해서 local max 값을 이용하면서 분모 $d_V$ 를 같이 업데이트할 수 있게 되었다. 이 수식은 여전히 safe 할까? 기존의 값을 안정화하던 $m_j$ 는 여전히 해당 값을 처리할 때 안정성을 제공하여 overflow/underflow를 방지한다. $d_j$ 의 내부에서 $e^{x_i-m_j}$ 를 계산할 때, 지수항은 $x_i-m_j \\le 0, e^{x_i-m_j} \\le 1$ 을 만족하기 때문에, $d_j$ 는 1 이상 j 이하의 값을 갖기 때문에 안정적이다.\nReferences Online normalizer calculation for softmax ","date":"2025-07-12T00:00:00Z","permalink":"https://jinseok-moon.github.io/ko/p/online-softmax/","title":"Online softmax"},{"content":"Python에서 triton 언어를 활용해서 triton 함수를 정의해준다. triton 함수는 @triton.jit decorator 형태로 정의됨. Triton의 컴파일 과정은 다른 포스트에서 따로 다루는걸로..\n@triton.jit def _fwd_kernel( Q, K, V, Out, Lse, TMP, softmax_scale, batch, nheads, ... , EVEN_M, EVEN_N, EVEN_HEADDIM, IS_CAUSAL: tl.constexpr, BLOCK_HEADDIM: tl.constexpr, BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, ): 함수를 정의했다면, 이제 컴파일러를 호출할 차례다.\nexport TRITON_ROOT=$(pip show triton | grep Location | cut -d\u0026#39; \u0026#39; -f2) rm -rf aot mkdir -p aot/fp16 python ${TRITON_ROOT}/triton/tools/compile.py \\ fmha_triton.py \\ -n _fwd_kernel \\ -o aot/fp16/fmha_kernel_d64_fp16 \\ --out-name fmha_d64_fp16 \\ -w 4 \\ -ns 1 \\ -s \u0026#34;*fp16, *fp16, *fp16, *fp16, *fp32, *fp32, fp32, \\ i32, i32, i32, \\ i32, i32, i32, \\ i32, i32, i32, \\ i32, i32, i32, \\ i32, i32, i32, \\ i32, i32, i32, \\ i1, i1, i1, \\ 1, \\ 64, \\ 128, \\ 128\u0026#34; \\ -g \u0026#34;(seqlen_q + 127) / 128, batch * nheads, 1\u0026#34; -n : python에 정의한 triton 커널 이름 -o : output 위치 \u0026ndash;output-name : C++에서 사용하게 될 함수 이름 -w : warp 개수 -ns : stage 개수 (pipelining) -s : signature. 함수의 파라미터 데이터 타입 -g : cuda grid, block 설정. batch, nheads 와 같은 파라미터로 들어오는 값을 사용할 수 있음. -n : python에 정의한 triton 커널 이름 -ns : stage 개수 (pipelining) -s : signature. 함수의 파라미터 데이터 타입 -g : cuda grid, block 설정. batch, nheads 와 같은 파라미터로 들어오는 값을 사용할 수 있음. 마지막으로 python ${TRITON_ROOT}/triton/tools/link.py aot/fp16/*.h -o aot/fmha_kernel_fp16 명령어를 실행시켜주면, 아래와 같은 파일들을 얻을 수 있음.\naot ├── fmha_kernel_fp16.c ├── fmha_kernel_fp16.h └── fp16 ├── fmha_kernel_d64_fp16.6979ce4b_0123456789101112131415161718192021222324252627.c └── fmha_kernel_d64_fp16.6979ce4b_0123456789101112131415161718192021222324252627.h 이 파일들을 실제 사용할 소스코드에서 extern “C”로 디맹글링해서 include 해주면 완성. 내부적으로 cuda driver api를 활용하도록 wrapper가 동작함.\nres = fmha_d64_fp16_default(stream, reinterpret_cast\u0026lt;CUdeviceptr\u0026gt;(Q), reinterpret_cast\u0026lt;CUdeviceptr\u0026gt;(K), reinterpret_cast\u0026lt;CUdeviceptr\u0026gt;(V), reinterpret_cast\u0026lt;CUdeviceptr\u0026gt;(output), reinterpret_cast\u0026lt;CUdeviceptr\u0026gt;(LSE), reinterpret_cast\u0026lt;CUdeviceptr\u0026gt;(TMP), mscale, head_num * head_dim * seq_len, head_dim, head_dim*head_num, head_num * head_dim * seq_len, head_dim, head_dim*head_num, head_num * head_dim * seq_len, head_dim, head_dim*head_num, head_num * head_dim * seq_len, head_dim, head_dim*head_num, head_num, seq_len, seq_len, seqlen_q_rounded, head_dim, batch_size, even_m, even_n, even_headdim); 이런식으로 파라미터를 맞춰넣어주고 실행시켜주면 된다.\n","date":"2025-07-05T00:00:00Z","permalink":"https://jinseok-moon.github.io/ko/p/triton-kernel-link/","title":"Triton kernel linking with CUDA C++"},{"content":"[CUDA] Pageable vs. Pinned Data Transfer CUDA에서 host에서 device로 memory를 복사하는 방법은 cudaMemcpy API 를 활용하는 방법이 있다. 기본적으로 별다른 작업 없이 선언된 host의 데이터는 pageable data로 동작한다. pageable data로부터 데이터를 device에 복사하기 위해서는 host 내부에서 pageable pinned memory로 한 번 옮겨가야 하기 때문에 속도가 느려지게 된다.\ncudaMallocHost 로 직접 memory pinning, non-pageable memory를 선언하게 되면, 해당 과정이 생략되기 때문에 복사가 더욱 빠르게 이루어진다. 1GB의 메모리를 device로 복사하는 경우의 두 방법의 속도 차이는 다음과 같다.\n$ ./pinned_memory Pinned memory Total time: 185.875 ms Average time per copy: 18.5875 ms Data size: 1 GB Bandwidth: 53.7997 GB/s Pageable memory Total time: 367.491 ms Average time per copy: 36.7491 ms Data size: 1 GB Bandwidth: 27.2116 GB/s Pinned memory를 사용하면 속도가 빨라짐을 알 수 있다. 하지만 시스템 메모리를 사용하는 만큼 상황에 맞게 사용해야함을 주의하자.\nReferences https://developer.nvidia.com/blog/how-optimize-data-transfers-cuda-cc/ ","date":"2025-06-19T00:00:00Z","permalink":"https://jinseok-moon.github.io/ko/p/pinned-memory/","title":"Pageable vs. pinned data transfer"},{"content":"Bank Conflicts CUDA를 공부하면 Shared Memory를 공부하게 되고 그러면서 Bank Conflicts에 대해서도 다루게 된다. Bank Conflicts는 메모리 요청이 뱅크에 중복되게 일어날 때 발생하는 것을 나타낸다.\nShared memory는 32-bit 크기를 가진 메모리 모듈 32개로 이루어져있는데, 64개의 fp32 데이터를 SRAM에 넣으면 아래와 같이 들어가게 된다. 즉, 32개의 bank에 순차적으로 속하게 됩니다.\n각 스레드가 각각 다른 뱅크에 접근할 때(1, 2번)에는 bank conflict가 발생하지 않습니다. 3번 경우에는 bank conflicts가 \u0026ldquo;일어날 가능성이\u0026rdquo; 있는데, 정확하게는 두가지 경우를 생각해볼 필요가 있습니다.\n스레드들이 같은 뱅크의 같은 주소에 접근할 때: 0-7번 스레드가 SRAM의 0번 데이터에 접근하는 경우를 나타냅니다. 이경우에는 broadcast access이므로, bank conflict가 일어나지 않습니다. 즉, 한 번의 memory request로 32개의 스레드가 데이터를 충족하게 됩니다. (memory request는 128바이트 단위라고 생각해주세요) 스레드들이 같은 뱅크의 다른 주소에 접근할 때: 0-3번 스레드는 SRAM의 0번 데이터에, 4-7번 스레드는 32번 데이터에 접근하는 경우를 나타냅니다. 이 경우에는 첫번째 메모리 요청에서 32번 주소의 데이터를 얻어올 수 없습니다. 왜냐하면 0번 뱅크는 앞선 요청에 따라 0번 데이터를 가지고 와야하거든요. 따라서 추가적인 메모리 요청이 필요하게 되고, 이게 성능저하를 야기시킵니다. 이런 경우가 바로 bank conflict를 나타냅니다. Experiment 실제로 그렇게 되는지 아래와 같은 4개의 커널을 실행해보겠습니다. 32x32의 행렬에 대한 연산을 편의상 그림에는 8x8로 나타내었습니다. 데이터는 Row-major로 저장되어있습니다. Kernel 0: ideal case 0번 커널은 이상적인 케이스입니다. 32개의 스레드가 순차적으로 DRAM input의 0-31번 주소의 데이터에 접근, SRAM의 0-31번 주소에 데이터를 저장합니다. 그 후 다시 SRAM의 데이터를 그대로 불러서 DRAM output의 0-31번 주소에 저장합니다.\nKernel 1: bank conflicts case 1번 커널은 bank conflict를 의도하는 코드입니다. DRAM에서 데이터를 로드해서, 일부러 SRAM의 0번 뱅크에 모든 데이터를 처리합니다. 결과 31번의 bank conflict가 발생해서 32개의 wavefront가 발생합니다. wavefront는 직렬화되어 처리됩니다.\nKernel 2: good case 2번 커널은 각자 다른 뱅크에, 인접하지 않은 데이터에 접근합니다. 그래도 괜찮습니다. 어짜피 각 메모리 컨트롤러는 자신에게 할당된 데이터를 독립적으로 가져올 거라서 성능적 손실은 발생하지 않습니다. 다만, 실제 상황에서는 사용하기 어려운 인덱싱이겠으니.. good case입니다.\nKernel 3: DRAM load overhead case 이 케이스는 DRAM에서 memory coalescing이 중요하다는 것을 보여드리려고 가져왔습니다. 2번 커널과 비슷하지만, DRAM에서 데이터를 읽어들일 때, 각자 다른 sector에 담겨있는 데이터를 가져옵니다. 기존 DRAM에서는 4바이트x32=128바이트의 데이터, 즉 4개의 섹터만 로드하면 되었는데, 이 커널에서는 한 섹터당 4바이트밖에 유효하지 않습니다. 다행히(?) 떨어져있는 데이터라도 4개의 섹터를 한번에 처리할 수 있어서 wavefront는 8개만 발생했네요. 그래도 결국 128바이트의 데이터를 부르기 위해서 1024바이트의 데이터를 읽어오는 성능 저하가 발생했습니다.\n결론 4개의 커널로 살펴보았듯, CUDA 프로그래밍에 있어서 중요한 부분은 어떻게 데이터를 일괄적으로 처리할 것인지 입니다. 데이터 layout을 바꾸어서 load하면 성능 손실을 막을 수 있겠죠.\nHow about fp64? 번외로, SRAM bank size는 4KB인데 fp64의 데이터는 어떻게 동작하게 될까요? Aligned\u0026amp;coalesced memory access를 전제로 했을 때, 이 경우에는 메모리 컨트롤러가 request를 128바이트씩 2개의 transaction으로 쪼개서 수행하게끔 디자인되어있다고 합니다. 그래서 bank conflict가 발생하지 않는다고 하네요.\nReferences https://forums.developer.nvidia.com/t/requesting-clarification-for-shared-memory-bank-conflicts-and-shared-memory-access/268574/3 ","date":"2024-12-02T00:00:00Z","permalink":"https://jinseok-moon.github.io/ko/p/bank-conflict/","title":"Bank Conflicts"}]