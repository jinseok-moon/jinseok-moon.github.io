---
title: "KFCNet 03 - 네트워크 모델링하기 (작성중)"
excerpt: "Korean Food Classifier Network - 03"

categories:
  - KFCNet
tags: 
  - [Convolutional Neural Network, Deep Learning, KFCNet]
toc: true
toc_sticky: true
toc_label: "On this page"
published: false

date: 2022-04-06
last_modified_at: 2022-04-19
---

## 데이터셋 클래스 정의
데이터셋을 보다 효과적으로 관리하기 위한 클래스를 정의한다. 
상위 디렉토리폴더의 경로만 받아서 train/test/validation 을 key로 삼고, dataset/dataloader를 value로 삼도록 정의하였다.

```python
import torch
from torchvision import datasets, transforms
from torchvision.transforms import Compose


class Dataset(object):
    def __init__(self, directory):
        """Load and Set Datasets

        Args:
            directory (str) : directory of dataset

        """

        self.transform = transforms.Compose([transforms.Resize((255,255)),
                                     transforms.ToTensor(),
                                   transforms.Normalize((0.5, 0.5, 0.5),(0.5, 0.5, 0.5))])

        self.data_set = {}
        self.data_loader = {}
        if directory[-1] != "/":
            directory += "/"

        for phase in ['train', 'test', 'val']:
            self.data_set[phase] = datasets.ImageFolder(directory+phase, transform=self.transform)  # Dataset
            self.data_loader[phase] = torch.utils.data.DataLoader(self.data_set[phase], batch_size=32, shuffle=True)

        self.num_classes = len(self.data_loader["train"].classes)
```

## 네트워크 모델링
데이터셋을 준비했으니, 이제는 네트워크를 짜야한다. 하지만 바닥부터 모든것을 짜기에는 학습이 잘 될지 모르고, 어려움이 많다. 이럴때는 미리 학습된 다양한 모델들을 찾아보는게 좋다. 핫한 CV 분야답게 수많은 오픈소스가 존재하고, 그중에서 ResNet50을 선택했다. 
Pytorch는 간편하게 전이학습 (Transfer Learning)을 지원하고, 다음과 같이 사용한다. 클래스 생성시에 기존의 resnet과는 class의 개수가 다르기 때문에, 그 부분을 고쳐줘야한다. 즉 Fully Connected Network의 출력 부분을 수정하면 된다.

```python
from torch import nn
import torchvision.models as models


class KFCNet(nn.Module):
  def __init__(self, num_classes):
      super(KFCNet, self).__init__()

      self.model = models.resnet50(pretrained=True)  # For transfer learning

      in_feat = self.model.fc.in_features
      self.fc = nn.Linear(in_feat, num_classes)  # Change output classes of fcn

  def forward(self, x):
      return self.model(x)
```

정의한 네트워크와 모델을 다음과 같이 불러올 수 있다. 다음, 사용할 optimizer와 손실함수를 결정하였다.
Classification task이기 때문에 CrossEntropyLoss를 사용하였고, optimizer는 SGD를 사용하였다. 이후 관련 parametric study를 진행할 예정이다.
```python
if torch.cuda.is_available():
    device = torch.device("cuda")
else:
    device = torch.device("cpu")

dataset = Dataset('./dataset/')
model = network.KFCNet(dataset.num_classes).to(device)

# 에포크, 배치 크기 지정
epochs = 100
batch_size = 64
learning_rate = 0.001

criterion = nn.CrossEntropyLoss()
optimizer = optim.SGD(model.parameters(), lr=learning_rate, momentum=0.9)
exp_lr_scheduler = lr_scheduler.StepLR(optimizer, step_size=7, gamma=0.1)
```

